// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: warhammer40kUnit.proto

#include "warhammer40kUnit.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_warhammer40kUnit_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_warhammer40kUnit_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Type;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_warhammer40kUnit_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Power;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_warhammer40kUnit_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Weapon;
}  // namespace protobuf_warhammer40kUnit_2eproto
class Warhammer40kUnitDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Warhammer40kUnit>
      _instance;
} _Warhammer40kUnit_default_instance_;
class Warhamer40kTransportDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Warhamer40kTransport>
      _instance;
} _Warhamer40kTransport_default_instance_;
class WeaponDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Weapon>
      _instance;
} _Weapon_default_instance_;
class TypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Type>
      _instance;
} _Type_default_instance_;
class PowerDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Power>
      _instance;
} _Power_default_instance_;
namespace protobuf_warhammer40kUnit_2eproto {
static void InitDefaultsWarhammer40kUnit() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Warhammer40kUnit_default_instance_;
    new (ptr) ::Warhammer40kUnit();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Warhammer40kUnit::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Warhammer40kUnit =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsWarhammer40kUnit}, {
      &protobuf_warhammer40kUnit_2eproto::scc_info_Power.base,
      &protobuf_warhammer40kUnit_2eproto::scc_info_Weapon.base,}};

static void InitDefaultsWarhamer40kTransport() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Warhamer40kTransport_default_instance_;
    new (ptr) ::Warhamer40kTransport();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Warhamer40kTransport::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Warhamer40kTransport =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsWarhamer40kTransport}, {
      &protobuf_warhammer40kUnit_2eproto::scc_info_Weapon.base,}};

static void InitDefaultsWeapon() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Weapon_default_instance_;
    new (ptr) ::Weapon();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Weapon::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Weapon =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsWeapon}, {
      &protobuf_warhammer40kUnit_2eproto::scc_info_Type.base,}};

static void InitDefaultsType() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Type_default_instance_;
    new (ptr) ::Type();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Type::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Type =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsType}, {}};

static void InitDefaultsPower() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Power_default_instance_;
    new (ptr) ::Power();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Power::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Power =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsPower}, {
      &protobuf_warhammer40kUnit_2eproto::scc_info_Weapon.base,}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_Warhammer40kUnit.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Warhamer40kTransport.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Weapon.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Type.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Power.base);
}

::google::protobuf::Metadata file_level_metadata[5];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, move_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, fly_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, min_move_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, leadership_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, weapon_skill_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, balistic_skill_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, toughness_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, wounds_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, save_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, power_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhammer40kUnit, weapon_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhamer40kTransport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhamer40kTransport, front_armor_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhamer40kTransport, side_armor_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhamer40kTransport, rear_armor_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhamer40kTransport, balistic_skill_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhamer40kTransport, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhamer40kTransport, transport_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhamer40kTransport, access_pts_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhamer40kTransport, fire_pts_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Warhamer40kTransport, weapon_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Weapon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Weapon, range_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Weapon, attacks_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Weapon, strengh_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Weapon, armor_peircing_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Weapon, text_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Weapon, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Weapon, damage_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Type, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Type, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Type, text_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Power, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Power, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Power, text_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Power, stats_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::Warhammer40kUnit)},
  { 16, -1, sizeof(::Warhamer40kTransport)},
  { 30, -1, sizeof(::Weapon)},
  { 42, -1, sizeof(::Type)},
  { 49, -1, sizeof(::Power)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::_Warhammer40kUnit_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::_Warhamer40kTransport_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::_Weapon_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::_Type_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::_Power_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  AssignDescriptors(
      "warhammer40kUnit.proto", schemas, file_default_instances, TableStruct::offsets,
      file_level_metadata, NULL, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 5);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\026warhammer40kUnit.proto\"\342\001\n\020Warhammer40"
      "kUnit\022\014\n\004move\030\013 \001(\r\022\013\n\003fly\030\001 \001(\010\022\020\n\010min_"
      "move\030\002 \001(\r\022\022\n\nleadership\030\003 \001(\r\022\024\n\014weapon"
      "_skill\030\004 \001(\r\022\026\n\016balistic_skill\030\005 \001(\r\022\021\n\t"
      "toughness\030\006 \001(\r\022\016\n\006wounds\030\007 \001(\r\022\014\n\004save\030"
      "\010 \001(\r\022\025\n\005power\030\t \003(\0132\006.Power\022\027\n\006weapon\030\n"
      " \003(\0132\007.Weapon\"\313\001\n\024Warhamer40kTransport\022\023"
      "\n\013front_armor\030\t \001(\r\022\022\n\nside_armor\030\001 \001(\r\022"
      "\022\n\nrear_armor\030\002 \001(\r\022\026\n\016balistic_skill\030\003 "
      "\001(\r\022\014\n\004type\030\004 \001(\t\022\021\n\ttransport\030\005 \001(\r\022\022\n\n"
      "access_pts\030\006 \001(\r\022\020\n\010fire_pts\030\007 \001(\r\022\027\n\006we"
      "apon\030\010 \003(\0132\007.Weapon\"\204\001\n\006Weapon\022\r\n\005range\030"
      "\001 \001(\r\022\017\n\007attacks\030\002 \001(\r\022\017\n\007strengh\030\003 \001(\r\022"
      "\026\n\016armor_peircing\030\004 \001(\r\022\014\n\004text\030\005 \001(\t\022\023\n"
      "\004type\030\006 \001(\0132\005.Type\022\016\n\006damage\030\007 \001(\r\"\"\n\004Ty"
      "pe\022\014\n\004name\030\001 \001(\t\022\014\n\004text\030\002 \001(\t\";\n\005Power\022"
      "\014\n\004name\030\001 \001(\t\022\014\n\004text\030\002 \001(\t\022\026\n\005stats\030\003 \001"
      "(\0132\007.Weaponb\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 699);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "warhammer40kUnit.proto", &protobuf_RegisterTypes);
}

void AddDescriptors() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_warhammer40kUnit_2eproto

// ===================================================================

void Warhammer40kUnit::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Warhammer40kUnit::kMoveFieldNumber;
const int Warhammer40kUnit::kFlyFieldNumber;
const int Warhammer40kUnit::kMinMoveFieldNumber;
const int Warhammer40kUnit::kLeadershipFieldNumber;
const int Warhammer40kUnit::kWeaponSkillFieldNumber;
const int Warhammer40kUnit::kBalisticSkillFieldNumber;
const int Warhammer40kUnit::kToughnessFieldNumber;
const int Warhammer40kUnit::kWoundsFieldNumber;
const int Warhammer40kUnit::kSaveFieldNumber;
const int Warhammer40kUnit::kPowerFieldNumber;
const int Warhammer40kUnit::kWeaponFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Warhammer40kUnit::Warhammer40kUnit()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_warhammer40kUnit_2eproto::scc_info_Warhammer40kUnit.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Warhammer40kUnit)
}
Warhammer40kUnit::Warhammer40kUnit(const Warhammer40kUnit& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      power_(from.power_),
      weapon_(from.weapon_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&fly_, &from.fly_,
    static_cast<size_t>(reinterpret_cast<char*>(&move_) -
    reinterpret_cast<char*>(&fly_)) + sizeof(move_));
  // @@protoc_insertion_point(copy_constructor:Warhammer40kUnit)
}

void Warhammer40kUnit::SharedCtor() {
  ::memset(&fly_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&move_) -
      reinterpret_cast<char*>(&fly_)) + sizeof(move_));
}

Warhammer40kUnit::~Warhammer40kUnit() {
  // @@protoc_insertion_point(destructor:Warhammer40kUnit)
  SharedDtor();
}

void Warhammer40kUnit::SharedDtor() {
}

void Warhammer40kUnit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Warhammer40kUnit::descriptor() {
  ::protobuf_warhammer40kUnit_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_warhammer40kUnit_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Warhammer40kUnit& Warhammer40kUnit::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_warhammer40kUnit_2eproto::scc_info_Warhammer40kUnit.base);
  return *internal_default_instance();
}


void Warhammer40kUnit::Clear() {
// @@protoc_insertion_point(message_clear_start:Warhammer40kUnit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  power_.Clear();
  weapon_.Clear();
  ::memset(&fly_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&move_) -
      reinterpret_cast<char*>(&fly_)) + sizeof(move_));
  _internal_metadata_.Clear();
}

bool Warhammer40kUnit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Warhammer40kUnit)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // bool fly = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fly_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 min_move = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_move_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 leadership = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leadership_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 weapon_skill = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &weapon_skill_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 balistic_skill = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &balistic_skill_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 toughness = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &toughness_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 wounds = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &wounds_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 save = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &save_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Power power = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_power()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Weapon weapon = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u /* 82 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_weapon()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 move = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &move_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Warhammer40kUnit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Warhammer40kUnit)
  return false;
#undef DO_
}

void Warhammer40kUnit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Warhammer40kUnit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool fly = 1;
  if (this->fly() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->fly(), output);
  }

  // uint32 min_move = 2;
  if (this->min_move() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->min_move(), output);
  }

  // uint32 leadership = 3;
  if (this->leadership() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->leadership(), output);
  }

  // uint32 weapon_skill = 4;
  if (this->weapon_skill() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->weapon_skill(), output);
  }

  // uint32 balistic_skill = 5;
  if (this->balistic_skill() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->balistic_skill(), output);
  }

  // uint32 toughness = 6;
  if (this->toughness() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->toughness(), output);
  }

  // uint32 wounds = 7;
  if (this->wounds() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->wounds(), output);
  }

  // uint32 save = 8;
  if (this->save() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->save(), output);
  }

  // repeated .Power power = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->power_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9,
      this->power(static_cast<int>(i)),
      output);
  }

  // repeated .Weapon weapon = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->weapon_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10,
      this->weapon(static_cast<int>(i)),
      output);
  }

  // uint32 move = 11;
  if (this->move() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->move(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:Warhammer40kUnit)
}

::google::protobuf::uint8* Warhammer40kUnit::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Warhammer40kUnit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool fly = 1;
  if (this->fly() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->fly(), target);
  }

  // uint32 min_move = 2;
  if (this->min_move() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->min_move(), target);
  }

  // uint32 leadership = 3;
  if (this->leadership() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->leadership(), target);
  }

  // uint32 weapon_skill = 4;
  if (this->weapon_skill() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->weapon_skill(), target);
  }

  // uint32 balistic_skill = 5;
  if (this->balistic_skill() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->balistic_skill(), target);
  }

  // uint32 toughness = 6;
  if (this->toughness() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->toughness(), target);
  }

  // uint32 wounds = 7;
  if (this->wounds() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->wounds(), target);
  }

  // uint32 save = 8;
  if (this->save() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->save(), target);
  }

  // repeated .Power power = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->power_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, this->power(static_cast<int>(i)), deterministic, target);
  }

  // repeated .Weapon weapon = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->weapon_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, this->weapon(static_cast<int>(i)), deterministic, target);
  }

  // uint32 move = 11;
  if (this->move() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->move(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Warhammer40kUnit)
  return target;
}

size_t Warhammer40kUnit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Warhammer40kUnit)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .Power power = 9;
  {
    unsigned int count = static_cast<unsigned int>(this->power_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->power(static_cast<int>(i)));
    }
  }

  // repeated .Weapon weapon = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->weapon_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->weapon(static_cast<int>(i)));
    }
  }

  // bool fly = 1;
  if (this->fly() != 0) {
    total_size += 1 + 1;
  }

  // uint32 min_move = 2;
  if (this->min_move() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->min_move());
  }

  // uint32 leadership = 3;
  if (this->leadership() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->leadership());
  }

  // uint32 weapon_skill = 4;
  if (this->weapon_skill() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->weapon_skill());
  }

  // uint32 balistic_skill = 5;
  if (this->balistic_skill() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->balistic_skill());
  }

  // uint32 toughness = 6;
  if (this->toughness() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->toughness());
  }

  // uint32 wounds = 7;
  if (this->wounds() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->wounds());
  }

  // uint32 save = 8;
  if (this->save() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->save());
  }

  // uint32 move = 11;
  if (this->move() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->move());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Warhammer40kUnit::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Warhammer40kUnit)
  GOOGLE_DCHECK_NE(&from, this);
  const Warhammer40kUnit* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Warhammer40kUnit>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Warhammer40kUnit)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Warhammer40kUnit)
    MergeFrom(*source);
  }
}

void Warhammer40kUnit::MergeFrom(const Warhammer40kUnit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Warhammer40kUnit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  power_.MergeFrom(from.power_);
  weapon_.MergeFrom(from.weapon_);
  if (from.fly() != 0) {
    set_fly(from.fly());
  }
  if (from.min_move() != 0) {
    set_min_move(from.min_move());
  }
  if (from.leadership() != 0) {
    set_leadership(from.leadership());
  }
  if (from.weapon_skill() != 0) {
    set_weapon_skill(from.weapon_skill());
  }
  if (from.balistic_skill() != 0) {
    set_balistic_skill(from.balistic_skill());
  }
  if (from.toughness() != 0) {
    set_toughness(from.toughness());
  }
  if (from.wounds() != 0) {
    set_wounds(from.wounds());
  }
  if (from.save() != 0) {
    set_save(from.save());
  }
  if (from.move() != 0) {
    set_move(from.move());
  }
}

void Warhammer40kUnit::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Warhammer40kUnit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Warhammer40kUnit::CopyFrom(const Warhammer40kUnit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Warhammer40kUnit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Warhammer40kUnit::IsInitialized() const {
  return true;
}

void Warhammer40kUnit::Swap(Warhammer40kUnit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Warhammer40kUnit::InternalSwap(Warhammer40kUnit* other) {
  using std::swap;
  CastToBase(&power_)->InternalSwap(CastToBase(&other->power_));
  CastToBase(&weapon_)->InternalSwap(CastToBase(&other->weapon_));
  swap(fly_, other->fly_);
  swap(min_move_, other->min_move_);
  swap(leadership_, other->leadership_);
  swap(weapon_skill_, other->weapon_skill_);
  swap(balistic_skill_, other->balistic_skill_);
  swap(toughness_, other->toughness_);
  swap(wounds_, other->wounds_);
  swap(save_, other->save_);
  swap(move_, other->move_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Warhammer40kUnit::GetMetadata() const {
  protobuf_warhammer40kUnit_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_warhammer40kUnit_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Warhamer40kTransport::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Warhamer40kTransport::kFrontArmorFieldNumber;
const int Warhamer40kTransport::kSideArmorFieldNumber;
const int Warhamer40kTransport::kRearArmorFieldNumber;
const int Warhamer40kTransport::kBalisticSkillFieldNumber;
const int Warhamer40kTransport::kTypeFieldNumber;
const int Warhamer40kTransport::kTransportFieldNumber;
const int Warhamer40kTransport::kAccessPtsFieldNumber;
const int Warhamer40kTransport::kFirePtsFieldNumber;
const int Warhamer40kTransport::kWeaponFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Warhamer40kTransport::Warhamer40kTransport()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_warhammer40kUnit_2eproto::scc_info_Warhamer40kTransport.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Warhamer40kTransport)
}
Warhamer40kTransport::Warhamer40kTransport(const Warhamer40kTransport& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      weapon_(from.weapon_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.type().size() > 0) {
    type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
  }
  ::memcpy(&side_armor_, &from.side_armor_,
    static_cast<size_t>(reinterpret_cast<char*>(&front_armor_) -
    reinterpret_cast<char*>(&side_armor_)) + sizeof(front_armor_));
  // @@protoc_insertion_point(copy_constructor:Warhamer40kTransport)
}

void Warhamer40kTransport::SharedCtor() {
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&side_armor_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&front_armor_) -
      reinterpret_cast<char*>(&side_armor_)) + sizeof(front_armor_));
}

Warhamer40kTransport::~Warhamer40kTransport() {
  // @@protoc_insertion_point(destructor:Warhamer40kTransport)
  SharedDtor();
}

void Warhamer40kTransport::SharedDtor() {
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Warhamer40kTransport::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Warhamer40kTransport::descriptor() {
  ::protobuf_warhammer40kUnit_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_warhammer40kUnit_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Warhamer40kTransport& Warhamer40kTransport::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_warhammer40kUnit_2eproto::scc_info_Warhamer40kTransport.base);
  return *internal_default_instance();
}


void Warhamer40kTransport::Clear() {
// @@protoc_insertion_point(message_clear_start:Warhamer40kTransport)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  weapon_.Clear();
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&side_armor_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&front_armor_) -
      reinterpret_cast<char*>(&side_armor_)) + sizeof(front_armor_));
  _internal_metadata_.Clear();
}

bool Warhamer40kTransport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Warhamer40kTransport)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 side_armor = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &side_armor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 rear_armor = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rear_armor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 balistic_skill = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &balistic_skill_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->type().data(), static_cast<int>(this->type().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Warhamer40kTransport.type"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 transport = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &transport_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 access_pts = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &access_pts_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 fire_pts = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fire_pts_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Weapon weapon = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_weapon()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 front_armor = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &front_armor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Warhamer40kTransport)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Warhamer40kTransport)
  return false;
#undef DO_
}

void Warhamer40kTransport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Warhamer40kTransport)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 side_armor = 1;
  if (this->side_armor() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->side_armor(), output);
  }

  // uint32 rear_armor = 2;
  if (this->rear_armor() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->rear_armor(), output);
  }

  // uint32 balistic_skill = 3;
  if (this->balistic_skill() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->balistic_skill(), output);
  }

  // string type = 4;
  if (this->type().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->type().data(), static_cast<int>(this->type().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Warhamer40kTransport.type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->type(), output);
  }

  // uint32 transport = 5;
  if (this->transport() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->transport(), output);
  }

  // uint32 access_pts = 6;
  if (this->access_pts() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->access_pts(), output);
  }

  // uint32 fire_pts = 7;
  if (this->fire_pts() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->fire_pts(), output);
  }

  // repeated .Weapon weapon = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->weapon_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8,
      this->weapon(static_cast<int>(i)),
      output);
  }

  // uint32 front_armor = 9;
  if (this->front_armor() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->front_armor(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:Warhamer40kTransport)
}

::google::protobuf::uint8* Warhamer40kTransport::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Warhamer40kTransport)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 side_armor = 1;
  if (this->side_armor() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->side_armor(), target);
  }

  // uint32 rear_armor = 2;
  if (this->rear_armor() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->rear_armor(), target);
  }

  // uint32 balistic_skill = 3;
  if (this->balistic_skill() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->balistic_skill(), target);
  }

  // string type = 4;
  if (this->type().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->type().data(), static_cast<int>(this->type().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Warhamer40kTransport.type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->type(), target);
  }

  // uint32 transport = 5;
  if (this->transport() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->transport(), target);
  }

  // uint32 access_pts = 6;
  if (this->access_pts() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->access_pts(), target);
  }

  // uint32 fire_pts = 7;
  if (this->fire_pts() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->fire_pts(), target);
  }

  // repeated .Weapon weapon = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->weapon_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, this->weapon(static_cast<int>(i)), deterministic, target);
  }

  // uint32 front_armor = 9;
  if (this->front_armor() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->front_armor(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Warhamer40kTransport)
  return target;
}

size_t Warhamer40kTransport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Warhamer40kTransport)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .Weapon weapon = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->weapon_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->weapon(static_cast<int>(i)));
    }
  }

  // string type = 4;
  if (this->type().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->type());
  }

  // uint32 side_armor = 1;
  if (this->side_armor() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->side_armor());
  }

  // uint32 rear_armor = 2;
  if (this->rear_armor() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->rear_armor());
  }

  // uint32 balistic_skill = 3;
  if (this->balistic_skill() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->balistic_skill());
  }

  // uint32 transport = 5;
  if (this->transport() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->transport());
  }

  // uint32 access_pts = 6;
  if (this->access_pts() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->access_pts());
  }

  // uint32 fire_pts = 7;
  if (this->fire_pts() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->fire_pts());
  }

  // uint32 front_armor = 9;
  if (this->front_armor() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->front_armor());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Warhamer40kTransport::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Warhamer40kTransport)
  GOOGLE_DCHECK_NE(&from, this);
  const Warhamer40kTransport* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Warhamer40kTransport>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Warhamer40kTransport)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Warhamer40kTransport)
    MergeFrom(*source);
  }
}

void Warhamer40kTransport::MergeFrom(const Warhamer40kTransport& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Warhamer40kTransport)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  weapon_.MergeFrom(from.weapon_);
  if (from.type().size() > 0) {

    type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
  }
  if (from.side_armor() != 0) {
    set_side_armor(from.side_armor());
  }
  if (from.rear_armor() != 0) {
    set_rear_armor(from.rear_armor());
  }
  if (from.balistic_skill() != 0) {
    set_balistic_skill(from.balistic_skill());
  }
  if (from.transport() != 0) {
    set_transport(from.transport());
  }
  if (from.access_pts() != 0) {
    set_access_pts(from.access_pts());
  }
  if (from.fire_pts() != 0) {
    set_fire_pts(from.fire_pts());
  }
  if (from.front_armor() != 0) {
    set_front_armor(from.front_armor());
  }
}

void Warhamer40kTransport::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Warhamer40kTransport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Warhamer40kTransport::CopyFrom(const Warhamer40kTransport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Warhamer40kTransport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Warhamer40kTransport::IsInitialized() const {
  return true;
}

void Warhamer40kTransport::Swap(Warhamer40kTransport* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Warhamer40kTransport::InternalSwap(Warhamer40kTransport* other) {
  using std::swap;
  CastToBase(&weapon_)->InternalSwap(CastToBase(&other->weapon_));
  type_.Swap(&other->type_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(side_armor_, other->side_armor_);
  swap(rear_armor_, other->rear_armor_);
  swap(balistic_skill_, other->balistic_skill_);
  swap(transport_, other->transport_);
  swap(access_pts_, other->access_pts_);
  swap(fire_pts_, other->fire_pts_);
  swap(front_armor_, other->front_armor_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Warhamer40kTransport::GetMetadata() const {
  protobuf_warhammer40kUnit_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_warhammer40kUnit_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Weapon::InitAsDefaultInstance() {
  ::_Weapon_default_instance_._instance.get_mutable()->type_ = const_cast< ::Type*>(
      ::Type::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Weapon::kRangeFieldNumber;
const int Weapon::kAttacksFieldNumber;
const int Weapon::kStrenghFieldNumber;
const int Weapon::kArmorPeircingFieldNumber;
const int Weapon::kTextFieldNumber;
const int Weapon::kTypeFieldNumber;
const int Weapon::kDamageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Weapon::Weapon()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_warhammer40kUnit_2eproto::scc_info_Weapon.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Weapon)
}
Weapon::Weapon(const Weapon& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.text().size() > 0) {
    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
  if (from.has_type()) {
    type_ = new ::Type(*from.type_);
  } else {
    type_ = NULL;
  }
  ::memcpy(&range_, &from.range_,
    static_cast<size_t>(reinterpret_cast<char*>(&damage_) -
    reinterpret_cast<char*>(&range_)) + sizeof(damage_));
  // @@protoc_insertion_point(copy_constructor:Weapon)
}

void Weapon::SharedCtor() {
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&damage_) -
      reinterpret_cast<char*>(&type_)) + sizeof(damage_));
}

Weapon::~Weapon() {
  // @@protoc_insertion_point(destructor:Weapon)
  SharedDtor();
}

void Weapon::SharedDtor() {
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete type_;
}

void Weapon::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Weapon::descriptor() {
  ::protobuf_warhammer40kUnit_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_warhammer40kUnit_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Weapon& Weapon::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_warhammer40kUnit_2eproto::scc_info_Weapon.base);
  return *internal_default_instance();
}


void Weapon::Clear() {
// @@protoc_insertion_point(message_clear_start:Weapon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && type_ != NULL) {
    delete type_;
  }
  type_ = NULL;
  ::memset(&range_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&damage_) -
      reinterpret_cast<char*>(&range_)) + sizeof(damage_));
  _internal_metadata_.Clear();
}

bool Weapon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Weapon)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 range = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &range_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 attacks = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attacks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 strengh = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &strengh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 armor_peircing = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &armor_peircing_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string text = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->text().data(), static_cast<int>(this->text().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Weapon.text"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Type type = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 damage = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &damage_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Weapon)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Weapon)
  return false;
#undef DO_
}

void Weapon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Weapon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 range = 1;
  if (this->range() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->range(), output);
  }

  // uint32 attacks = 2;
  if (this->attacks() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->attacks(), output);
  }

  // uint32 strengh = 3;
  if (this->strengh() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->strengh(), output);
  }

  // uint32 armor_peircing = 4;
  if (this->armor_peircing() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->armor_peircing(), output);
  }

  // string text = 5;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), static_cast<int>(this->text().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Weapon.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->text(), output);
  }

  // .Type type = 6;
  if (this->has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->_internal_type(), output);
  }

  // uint32 damage = 7;
  if (this->damage() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->damage(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:Weapon)
}

::google::protobuf::uint8* Weapon::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Weapon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 range = 1;
  if (this->range() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->range(), target);
  }

  // uint32 attacks = 2;
  if (this->attacks() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->attacks(), target);
  }

  // uint32 strengh = 3;
  if (this->strengh() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->strengh(), target);
  }

  // uint32 armor_peircing = 4;
  if (this->armor_peircing() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->armor_peircing(), target);
  }

  // string text = 5;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), static_cast<int>(this->text().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Weapon.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->text(), target);
  }

  // .Type type = 6;
  if (this->has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->_internal_type(), deterministic, target);
  }

  // uint32 damage = 7;
  if (this->damage() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->damage(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Weapon)
  return target;
}

size_t Weapon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Weapon)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // string text = 5;
  if (this->text().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->text());
  }

  // .Type type = 6;
  if (this->has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *type_);
  }

  // uint32 range = 1;
  if (this->range() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->range());
  }

  // uint32 attacks = 2;
  if (this->attacks() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->attacks());
  }

  // uint32 strengh = 3;
  if (this->strengh() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->strengh());
  }

  // uint32 armor_peircing = 4;
  if (this->armor_peircing() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->armor_peircing());
  }

  // uint32 damage = 7;
  if (this->damage() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->damage());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Weapon::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Weapon)
  GOOGLE_DCHECK_NE(&from, this);
  const Weapon* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Weapon>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Weapon)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Weapon)
    MergeFrom(*source);
  }
}

void Weapon::MergeFrom(const Weapon& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Weapon)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.text().size() > 0) {

    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
  if (from.has_type()) {
    mutable_type()->::Type::MergeFrom(from.type());
  }
  if (from.range() != 0) {
    set_range(from.range());
  }
  if (from.attacks() != 0) {
    set_attacks(from.attacks());
  }
  if (from.strengh() != 0) {
    set_strengh(from.strengh());
  }
  if (from.armor_peircing() != 0) {
    set_armor_peircing(from.armor_peircing());
  }
  if (from.damage() != 0) {
    set_damage(from.damage());
  }
}

void Weapon::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Weapon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Weapon::CopyFrom(const Weapon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Weapon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Weapon::IsInitialized() const {
  return true;
}

void Weapon::Swap(Weapon* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Weapon::InternalSwap(Weapon* other) {
  using std::swap;
  text_.Swap(&other->text_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(type_, other->type_);
  swap(range_, other->range_);
  swap(attacks_, other->attacks_);
  swap(strengh_, other->strengh_);
  swap(armor_peircing_, other->armor_peircing_);
  swap(damage_, other->damage_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Weapon::GetMetadata() const {
  protobuf_warhammer40kUnit_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_warhammer40kUnit_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Type::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Type::kNameFieldNumber;
const int Type::kTextFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Type::Type()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_warhammer40kUnit_2eproto::scc_info_Type.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Type)
}
Type::Type(const Type& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.name().size() > 0) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.text().size() > 0) {
    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
  // @@protoc_insertion_point(copy_constructor:Type)
}

void Type::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Type::~Type() {
  // @@protoc_insertion_point(destructor:Type)
  SharedDtor();
}

void Type::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Type::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Type::descriptor() {
  ::protobuf_warhammer40kUnit_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_warhammer40kUnit_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Type& Type::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_warhammer40kUnit_2eproto::scc_info_Type.base);
  return *internal_default_instance();
}


void Type::Clear() {
// @@protoc_insertion_point(message_clear_start:Type)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

bool Type::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Type)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Type.name"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string text = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->text().data(), static_cast<int>(this->text().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Type.text"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Type)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Type)
  return false;
#undef DO_
}

void Type::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Type)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Type.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // string text = 2;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), static_cast<int>(this->text().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Type.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->text(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:Type)
}

::google::protobuf::uint8* Type::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Type)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Type.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // string text = 2;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), static_cast<int>(this->text().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Type.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->text(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Type)
  return target;
}

size_t Type::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Type)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // string text = 2;
  if (this->text().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->text());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Type::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Type)
  GOOGLE_DCHECK_NE(&from, this);
  const Type* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Type>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Type)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Type)
    MergeFrom(*source);
  }
}

void Type::MergeFrom(const Type& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Type)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.text().size() > 0) {

    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
}

void Type::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Type)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Type::CopyFrom(const Type& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Type)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Type::IsInitialized() const {
  return true;
}

void Type::Swap(Type* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Type::InternalSwap(Type* other) {
  using std::swap;
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  text_.Swap(&other->text_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Type::GetMetadata() const {
  protobuf_warhammer40kUnit_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_warhammer40kUnit_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Power::InitAsDefaultInstance() {
  ::_Power_default_instance_._instance.get_mutable()->stats_ = const_cast< ::Weapon*>(
      ::Weapon::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Power::kNameFieldNumber;
const int Power::kTextFieldNumber;
const int Power::kStatsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Power::Power()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_warhammer40kUnit_2eproto::scc_info_Power.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Power)
}
Power::Power(const Power& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.name().size() > 0) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.text().size() > 0) {
    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
  if (from.has_stats()) {
    stats_ = new ::Weapon(*from.stats_);
  } else {
    stats_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:Power)
}

void Power::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  stats_ = NULL;
}

Power::~Power() {
  // @@protoc_insertion_point(destructor:Power)
  SharedDtor();
}

void Power::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete stats_;
}

void Power::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Power::descriptor() {
  ::protobuf_warhammer40kUnit_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_warhammer40kUnit_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Power& Power::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_warhammer40kUnit_2eproto::scc_info_Power.base);
  return *internal_default_instance();
}


void Power::Clear() {
// @@protoc_insertion_point(message_clear_start:Power)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) {
    delete stats_;
  }
  stats_ = NULL;
  _internal_metadata_.Clear();
}

bool Power::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Power)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Power.name"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string text = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->text().data(), static_cast<int>(this->text().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Power.text"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Weapon stats = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_stats()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Power)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Power)
  return false;
#undef DO_
}

void Power::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Power)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Power.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // string text = 2;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), static_cast<int>(this->text().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Power.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->text(), output);
  }

  // .Weapon stats = 3;
  if (this->has_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->_internal_stats(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:Power)
}

::google::protobuf::uint8* Power::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Power)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Power.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // string text = 2;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), static_cast<int>(this->text().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Power.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->text(), target);
  }

  // .Weapon stats = 3;
  if (this->has_stats()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->_internal_stats(), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Power)
  return target;
}

size_t Power::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Power)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // string text = 2;
  if (this->text().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->text());
  }

  // .Weapon stats = 3;
  if (this->has_stats()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *stats_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Power::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Power)
  GOOGLE_DCHECK_NE(&from, this);
  const Power* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Power>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Power)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Power)
    MergeFrom(*source);
  }
}

void Power::MergeFrom(const Power& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Power)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.text().size() > 0) {

    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
  if (from.has_stats()) {
    mutable_stats()->::Weapon::MergeFrom(from.stats());
  }
}

void Power::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Power)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Power::CopyFrom(const Power& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Power)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Power::IsInitialized() const {
  return true;
}

void Power::Swap(Power* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Power::InternalSwap(Power* other) {
  using std::swap;
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  text_.Swap(&other->text_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(stats_, other->stats_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Power::GetMetadata() const {
  protobuf_warhammer40kUnit_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_warhammer40kUnit_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Warhammer40kUnit* Arena::CreateMaybeMessage< ::Warhammer40kUnit >(Arena* arena) {
  return Arena::CreateInternal< ::Warhammer40kUnit >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Warhamer40kTransport* Arena::CreateMaybeMessage< ::Warhamer40kTransport >(Arena* arena) {
  return Arena::CreateInternal< ::Warhamer40kTransport >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Weapon* Arena::CreateMaybeMessage< ::Weapon >(Arena* arena) {
  return Arena::CreateInternal< ::Weapon >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Type* Arena::CreateMaybeMessage< ::Type >(Arena* arena) {
  return Arena::CreateInternal< ::Type >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Power* Arena::CreateMaybeMessage< ::Power >(Arena* arena) {
  return Arena::CreateInternal< ::Power >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
