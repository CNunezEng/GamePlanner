// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: warhammer40kUnit.proto

#ifndef PROTOBUF_INCLUDED_warhammer40kUnit_2eproto
#define PROTOBUF_INCLUDED_warhammer40kUnit_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_warhammer40kUnit_2eproto 

namespace protobuf_warhammer40kUnit_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_warhammer40kUnit_2eproto
class Power;
class PowerDefaultTypeInternal;
extern PowerDefaultTypeInternal _Power_default_instance_;
class Type;
class TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class Warhamer40kTransport;
class Warhamer40kTransportDefaultTypeInternal;
extern Warhamer40kTransportDefaultTypeInternal _Warhamer40kTransport_default_instance_;
class Warhammer40kUnit;
class Warhammer40kUnitDefaultTypeInternal;
extern Warhammer40kUnitDefaultTypeInternal _Warhammer40kUnit_default_instance_;
class Weapon;
class WeaponDefaultTypeInternal;
extern WeaponDefaultTypeInternal _Weapon_default_instance_;
namespace google {
namespace protobuf {
template<> ::Power* Arena::CreateMaybeMessage<::Power>(Arena*);
template<> ::Type* Arena::CreateMaybeMessage<::Type>(Arena*);
template<> ::Warhamer40kTransport* Arena::CreateMaybeMessage<::Warhamer40kTransport>(Arena*);
template<> ::Warhammer40kUnit* Arena::CreateMaybeMessage<::Warhammer40kUnit>(Arena*);
template<> ::Weapon* Arena::CreateMaybeMessage<::Weapon>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class Warhammer40kUnit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Warhammer40kUnit) */ {
 public:
  Warhammer40kUnit();
  virtual ~Warhammer40kUnit();

  Warhammer40kUnit(const Warhammer40kUnit& from);

  inline Warhammer40kUnit& operator=(const Warhammer40kUnit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Warhammer40kUnit(Warhammer40kUnit&& from) noexcept
    : Warhammer40kUnit() {
    *this = ::std::move(from);
  }

  inline Warhammer40kUnit& operator=(Warhammer40kUnit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Warhammer40kUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Warhammer40kUnit* internal_default_instance() {
    return reinterpret_cast<const Warhammer40kUnit*>(
               &_Warhammer40kUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Warhammer40kUnit* other);
  friend void swap(Warhammer40kUnit& a, Warhammer40kUnit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Warhammer40kUnit* New() const final {
    return CreateMaybeMessage<Warhammer40kUnit>(NULL);
  }

  Warhammer40kUnit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Warhammer40kUnit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Warhammer40kUnit& from);
  void MergeFrom(const Warhammer40kUnit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Warhammer40kUnit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Power power = 9;
  int power_size() const;
  void clear_power();
  static const int kPowerFieldNumber = 9;
  ::Power* mutable_power(int index);
  ::google::protobuf::RepeatedPtrField< ::Power >*
      mutable_power();
  const ::Power& power(int index) const;
  ::Power* add_power();
  const ::google::protobuf::RepeatedPtrField< ::Power >&
      power() const;

  // repeated .Weapon weapon = 10;
  int weapon_size() const;
  void clear_weapon();
  static const int kWeaponFieldNumber = 10;
  ::Weapon* mutable_weapon(int index);
  ::google::protobuf::RepeatedPtrField< ::Weapon >*
      mutable_weapon();
  const ::Weapon& weapon(int index) const;
  ::Weapon* add_weapon();
  const ::google::protobuf::RepeatedPtrField< ::Weapon >&
      weapon() const;

  // bool fly = 1;
  void clear_fly();
  static const int kFlyFieldNumber = 1;
  bool fly() const;
  void set_fly(bool value);

  // uint32 min_move = 2;
  void clear_min_move();
  static const int kMinMoveFieldNumber = 2;
  ::google::protobuf::uint32 min_move() const;
  void set_min_move(::google::protobuf::uint32 value);

  // uint32 leadership = 3;
  void clear_leadership();
  static const int kLeadershipFieldNumber = 3;
  ::google::protobuf::uint32 leadership() const;
  void set_leadership(::google::protobuf::uint32 value);

  // uint32 weapon_skill = 4;
  void clear_weapon_skill();
  static const int kWeaponSkillFieldNumber = 4;
  ::google::protobuf::uint32 weapon_skill() const;
  void set_weapon_skill(::google::protobuf::uint32 value);

  // uint32 balistic_skill = 5;
  void clear_balistic_skill();
  static const int kBalisticSkillFieldNumber = 5;
  ::google::protobuf::uint32 balistic_skill() const;
  void set_balistic_skill(::google::protobuf::uint32 value);

  // uint32 toughness = 6;
  void clear_toughness();
  static const int kToughnessFieldNumber = 6;
  ::google::protobuf::uint32 toughness() const;
  void set_toughness(::google::protobuf::uint32 value);

  // uint32 wounds = 7;
  void clear_wounds();
  static const int kWoundsFieldNumber = 7;
  ::google::protobuf::uint32 wounds() const;
  void set_wounds(::google::protobuf::uint32 value);

  // uint32 save = 8;
  void clear_save();
  static const int kSaveFieldNumber = 8;
  ::google::protobuf::uint32 save() const;
  void set_save(::google::protobuf::uint32 value);

  // uint32 move = 11;
  void clear_move();
  static const int kMoveFieldNumber = 11;
  ::google::protobuf::uint32 move() const;
  void set_move(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Warhammer40kUnit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Power > power_;
  ::google::protobuf::RepeatedPtrField< ::Weapon > weapon_;
  bool fly_;
  ::google::protobuf::uint32 min_move_;
  ::google::protobuf::uint32 leadership_;
  ::google::protobuf::uint32 weapon_skill_;
  ::google::protobuf::uint32 balistic_skill_;
  ::google::protobuf::uint32 toughness_;
  ::google::protobuf::uint32 wounds_;
  ::google::protobuf::uint32 save_;
  ::google::protobuf::uint32 move_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_warhammer40kUnit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Warhamer40kTransport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Warhamer40kTransport) */ {
 public:
  Warhamer40kTransport();
  virtual ~Warhamer40kTransport();

  Warhamer40kTransport(const Warhamer40kTransport& from);

  inline Warhamer40kTransport& operator=(const Warhamer40kTransport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Warhamer40kTransport(Warhamer40kTransport&& from) noexcept
    : Warhamer40kTransport() {
    *this = ::std::move(from);
  }

  inline Warhamer40kTransport& operator=(Warhamer40kTransport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Warhamer40kTransport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Warhamer40kTransport* internal_default_instance() {
    return reinterpret_cast<const Warhamer40kTransport*>(
               &_Warhamer40kTransport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Warhamer40kTransport* other);
  friend void swap(Warhamer40kTransport& a, Warhamer40kTransport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Warhamer40kTransport* New() const final {
    return CreateMaybeMessage<Warhamer40kTransport>(NULL);
  }

  Warhamer40kTransport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Warhamer40kTransport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Warhamer40kTransport& from);
  void MergeFrom(const Warhamer40kTransport& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Warhamer40kTransport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Weapon weapon = 8;
  int weapon_size() const;
  void clear_weapon();
  static const int kWeaponFieldNumber = 8;
  ::Weapon* mutable_weapon(int index);
  ::google::protobuf::RepeatedPtrField< ::Weapon >*
      mutable_weapon();
  const ::Weapon& weapon(int index) const;
  ::Weapon* add_weapon();
  const ::google::protobuf::RepeatedPtrField< ::Weapon >&
      weapon() const;

  // string type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // uint32 side_armor = 1;
  void clear_side_armor();
  static const int kSideArmorFieldNumber = 1;
  ::google::protobuf::uint32 side_armor() const;
  void set_side_armor(::google::protobuf::uint32 value);

  // uint32 rear_armor = 2;
  void clear_rear_armor();
  static const int kRearArmorFieldNumber = 2;
  ::google::protobuf::uint32 rear_armor() const;
  void set_rear_armor(::google::protobuf::uint32 value);

  // uint32 balistic_skill = 3;
  void clear_balistic_skill();
  static const int kBalisticSkillFieldNumber = 3;
  ::google::protobuf::uint32 balistic_skill() const;
  void set_balistic_skill(::google::protobuf::uint32 value);

  // uint32 transport = 5;
  void clear_transport();
  static const int kTransportFieldNumber = 5;
  ::google::protobuf::uint32 transport() const;
  void set_transport(::google::protobuf::uint32 value);

  // uint32 access_pts = 6;
  void clear_access_pts();
  static const int kAccessPtsFieldNumber = 6;
  ::google::protobuf::uint32 access_pts() const;
  void set_access_pts(::google::protobuf::uint32 value);

  // uint32 fire_pts = 7;
  void clear_fire_pts();
  static const int kFirePtsFieldNumber = 7;
  ::google::protobuf::uint32 fire_pts() const;
  void set_fire_pts(::google::protobuf::uint32 value);

  // uint32 front_armor = 9;
  void clear_front_armor();
  static const int kFrontArmorFieldNumber = 9;
  ::google::protobuf::uint32 front_armor() const;
  void set_front_armor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Warhamer40kTransport)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Weapon > weapon_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::uint32 side_armor_;
  ::google::protobuf::uint32 rear_armor_;
  ::google::protobuf::uint32 balistic_skill_;
  ::google::protobuf::uint32 transport_;
  ::google::protobuf::uint32 access_pts_;
  ::google::protobuf::uint32 fire_pts_;
  ::google::protobuf::uint32 front_armor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_warhammer40kUnit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Weapon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Weapon) */ {
 public:
  Weapon();
  virtual ~Weapon();

  Weapon(const Weapon& from);

  inline Weapon& operator=(const Weapon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Weapon(Weapon&& from) noexcept
    : Weapon() {
    *this = ::std::move(from);
  }

  inline Weapon& operator=(Weapon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Weapon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Weapon* internal_default_instance() {
    return reinterpret_cast<const Weapon*>(
               &_Weapon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Weapon* other);
  friend void swap(Weapon& a, Weapon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Weapon* New() const final {
    return CreateMaybeMessage<Weapon>(NULL);
  }

  Weapon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Weapon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Weapon& from);
  void MergeFrom(const Weapon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Weapon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 5;
  void clear_text();
  static const int kTextFieldNumber = 5;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // .Type type = 6;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  private:
  const ::Type& _internal_type() const;
  public:
  const ::Type& type() const;
  ::Type* release_type();
  ::Type* mutable_type();
  void set_allocated_type(::Type* type);

  // uint32 range = 1;
  void clear_range();
  static const int kRangeFieldNumber = 1;
  ::google::protobuf::uint32 range() const;
  void set_range(::google::protobuf::uint32 value);

  // uint32 attacks = 2;
  void clear_attacks();
  static const int kAttacksFieldNumber = 2;
  ::google::protobuf::uint32 attacks() const;
  void set_attacks(::google::protobuf::uint32 value);

  // uint32 strengh = 3;
  void clear_strengh();
  static const int kStrenghFieldNumber = 3;
  ::google::protobuf::uint32 strengh() const;
  void set_strengh(::google::protobuf::uint32 value);

  // uint32 armor_peircing = 4;
  void clear_armor_peircing();
  static const int kArmorPeircingFieldNumber = 4;
  ::google::protobuf::uint32 armor_peircing() const;
  void set_armor_peircing(::google::protobuf::uint32 value);

  // uint32 damage = 7;
  void clear_damage();
  static const int kDamageFieldNumber = 7;
  ::google::protobuf::uint32 damage() const;
  void set_damage(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Weapon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::Type* type_;
  ::google::protobuf::uint32 range_;
  ::google::protobuf::uint32 attacks_;
  ::google::protobuf::uint32 strengh_;
  ::google::protobuf::uint32 armor_peircing_;
  ::google::protobuf::uint32 damage_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_warhammer40kUnit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Type) */ {
 public:
  Type();
  virtual ~Type();

  Type(const Type& from);

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(Type&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Type* other);
  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type* New() const final {
    return CreateMaybeMessage<Type>(NULL);
  }

  Type* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:Type)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_warhammer40kUnit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Power : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Power) */ {
 public:
  Power();
  virtual ~Power();

  Power(const Power& from);

  inline Power& operator=(const Power& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Power(Power&& from) noexcept
    : Power() {
    *this = ::std::move(from);
  }

  inline Power& operator=(Power&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Power& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Power* internal_default_instance() {
    return reinterpret_cast<const Power*>(
               &_Power_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Power* other);
  friend void swap(Power& a, Power& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Power* New() const final {
    return CreateMaybeMessage<Power>(NULL);
  }

  Power* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Power>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Power& from);
  void MergeFrom(const Power& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Power* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // .Weapon stats = 3;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 3;
  private:
  const ::Weapon& _internal_stats() const;
  public:
  const ::Weapon& stats() const;
  ::Weapon* release_stats();
  ::Weapon* mutable_stats();
  void set_allocated_stats(::Weapon* stats);

  // @@protoc_insertion_point(class_scope:Power)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::Weapon* stats_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_warhammer40kUnit_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Warhammer40kUnit

// uint32 move = 11;
inline void Warhammer40kUnit::clear_move() {
  move_ = 0u;
}
inline ::google::protobuf::uint32 Warhammer40kUnit::move() const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.move)
  return move_;
}
inline void Warhammer40kUnit::set_move(::google::protobuf::uint32 value) {
  
  move_ = value;
  // @@protoc_insertion_point(field_set:Warhammer40kUnit.move)
}

// bool fly = 1;
inline void Warhammer40kUnit::clear_fly() {
  fly_ = false;
}
inline bool Warhammer40kUnit::fly() const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.fly)
  return fly_;
}
inline void Warhammer40kUnit::set_fly(bool value) {
  
  fly_ = value;
  // @@protoc_insertion_point(field_set:Warhammer40kUnit.fly)
}

// uint32 min_move = 2;
inline void Warhammer40kUnit::clear_min_move() {
  min_move_ = 0u;
}
inline ::google::protobuf::uint32 Warhammer40kUnit::min_move() const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.min_move)
  return min_move_;
}
inline void Warhammer40kUnit::set_min_move(::google::protobuf::uint32 value) {
  
  min_move_ = value;
  // @@protoc_insertion_point(field_set:Warhammer40kUnit.min_move)
}

// uint32 leadership = 3;
inline void Warhammer40kUnit::clear_leadership() {
  leadership_ = 0u;
}
inline ::google::protobuf::uint32 Warhammer40kUnit::leadership() const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.leadership)
  return leadership_;
}
inline void Warhammer40kUnit::set_leadership(::google::protobuf::uint32 value) {
  
  leadership_ = value;
  // @@protoc_insertion_point(field_set:Warhammer40kUnit.leadership)
}

// uint32 weapon_skill = 4;
inline void Warhammer40kUnit::clear_weapon_skill() {
  weapon_skill_ = 0u;
}
inline ::google::protobuf::uint32 Warhammer40kUnit::weapon_skill() const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.weapon_skill)
  return weapon_skill_;
}
inline void Warhammer40kUnit::set_weapon_skill(::google::protobuf::uint32 value) {
  
  weapon_skill_ = value;
  // @@protoc_insertion_point(field_set:Warhammer40kUnit.weapon_skill)
}

// uint32 balistic_skill = 5;
inline void Warhammer40kUnit::clear_balistic_skill() {
  balistic_skill_ = 0u;
}
inline ::google::protobuf::uint32 Warhammer40kUnit::balistic_skill() const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.balistic_skill)
  return balistic_skill_;
}
inline void Warhammer40kUnit::set_balistic_skill(::google::protobuf::uint32 value) {
  
  balistic_skill_ = value;
  // @@protoc_insertion_point(field_set:Warhammer40kUnit.balistic_skill)
}

// uint32 toughness = 6;
inline void Warhammer40kUnit::clear_toughness() {
  toughness_ = 0u;
}
inline ::google::protobuf::uint32 Warhammer40kUnit::toughness() const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.toughness)
  return toughness_;
}
inline void Warhammer40kUnit::set_toughness(::google::protobuf::uint32 value) {
  
  toughness_ = value;
  // @@protoc_insertion_point(field_set:Warhammer40kUnit.toughness)
}

// uint32 wounds = 7;
inline void Warhammer40kUnit::clear_wounds() {
  wounds_ = 0u;
}
inline ::google::protobuf::uint32 Warhammer40kUnit::wounds() const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.wounds)
  return wounds_;
}
inline void Warhammer40kUnit::set_wounds(::google::protobuf::uint32 value) {
  
  wounds_ = value;
  // @@protoc_insertion_point(field_set:Warhammer40kUnit.wounds)
}

// uint32 save = 8;
inline void Warhammer40kUnit::clear_save() {
  save_ = 0u;
}
inline ::google::protobuf::uint32 Warhammer40kUnit::save() const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.save)
  return save_;
}
inline void Warhammer40kUnit::set_save(::google::protobuf::uint32 value) {
  
  save_ = value;
  // @@protoc_insertion_point(field_set:Warhammer40kUnit.save)
}

// repeated .Power power = 9;
inline int Warhammer40kUnit::power_size() const {
  return power_.size();
}
inline void Warhammer40kUnit::clear_power() {
  power_.Clear();
}
inline ::Power* Warhammer40kUnit::mutable_power(int index) {
  // @@protoc_insertion_point(field_mutable:Warhammer40kUnit.power)
  return power_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Power >*
Warhammer40kUnit::mutable_power() {
  // @@protoc_insertion_point(field_mutable_list:Warhammer40kUnit.power)
  return &power_;
}
inline const ::Power& Warhammer40kUnit::power(int index) const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.power)
  return power_.Get(index);
}
inline ::Power* Warhammer40kUnit::add_power() {
  // @@protoc_insertion_point(field_add:Warhammer40kUnit.power)
  return power_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Power >&
Warhammer40kUnit::power() const {
  // @@protoc_insertion_point(field_list:Warhammer40kUnit.power)
  return power_;
}

// repeated .Weapon weapon = 10;
inline int Warhammer40kUnit::weapon_size() const {
  return weapon_.size();
}
inline void Warhammer40kUnit::clear_weapon() {
  weapon_.Clear();
}
inline ::Weapon* Warhammer40kUnit::mutable_weapon(int index) {
  // @@protoc_insertion_point(field_mutable:Warhammer40kUnit.weapon)
  return weapon_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Weapon >*
Warhammer40kUnit::mutable_weapon() {
  // @@protoc_insertion_point(field_mutable_list:Warhammer40kUnit.weapon)
  return &weapon_;
}
inline const ::Weapon& Warhammer40kUnit::weapon(int index) const {
  // @@protoc_insertion_point(field_get:Warhammer40kUnit.weapon)
  return weapon_.Get(index);
}
inline ::Weapon* Warhammer40kUnit::add_weapon() {
  // @@protoc_insertion_point(field_add:Warhammer40kUnit.weapon)
  return weapon_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Weapon >&
Warhammer40kUnit::weapon() const {
  // @@protoc_insertion_point(field_list:Warhammer40kUnit.weapon)
  return weapon_;
}

// -------------------------------------------------------------------

// Warhamer40kTransport

// uint32 front_armor = 9;
inline void Warhamer40kTransport::clear_front_armor() {
  front_armor_ = 0u;
}
inline ::google::protobuf::uint32 Warhamer40kTransport::front_armor() const {
  // @@protoc_insertion_point(field_get:Warhamer40kTransport.front_armor)
  return front_armor_;
}
inline void Warhamer40kTransport::set_front_armor(::google::protobuf::uint32 value) {
  
  front_armor_ = value;
  // @@protoc_insertion_point(field_set:Warhamer40kTransport.front_armor)
}

// uint32 side_armor = 1;
inline void Warhamer40kTransport::clear_side_armor() {
  side_armor_ = 0u;
}
inline ::google::protobuf::uint32 Warhamer40kTransport::side_armor() const {
  // @@protoc_insertion_point(field_get:Warhamer40kTransport.side_armor)
  return side_armor_;
}
inline void Warhamer40kTransport::set_side_armor(::google::protobuf::uint32 value) {
  
  side_armor_ = value;
  // @@protoc_insertion_point(field_set:Warhamer40kTransport.side_armor)
}

// uint32 rear_armor = 2;
inline void Warhamer40kTransport::clear_rear_armor() {
  rear_armor_ = 0u;
}
inline ::google::protobuf::uint32 Warhamer40kTransport::rear_armor() const {
  // @@protoc_insertion_point(field_get:Warhamer40kTransport.rear_armor)
  return rear_armor_;
}
inline void Warhamer40kTransport::set_rear_armor(::google::protobuf::uint32 value) {
  
  rear_armor_ = value;
  // @@protoc_insertion_point(field_set:Warhamer40kTransport.rear_armor)
}

// uint32 balistic_skill = 3;
inline void Warhamer40kTransport::clear_balistic_skill() {
  balistic_skill_ = 0u;
}
inline ::google::protobuf::uint32 Warhamer40kTransport::balistic_skill() const {
  // @@protoc_insertion_point(field_get:Warhamer40kTransport.balistic_skill)
  return balistic_skill_;
}
inline void Warhamer40kTransport::set_balistic_skill(::google::protobuf::uint32 value) {
  
  balistic_skill_ = value;
  // @@protoc_insertion_point(field_set:Warhamer40kTransport.balistic_skill)
}

// string type = 4;
inline void Warhamer40kTransport::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Warhamer40kTransport::type() const {
  // @@protoc_insertion_point(field_get:Warhamer40kTransport.type)
  return type_.GetNoArena();
}
inline void Warhamer40kTransport::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Warhamer40kTransport.type)
}
#if LANG_CXX11
inline void Warhamer40kTransport::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Warhamer40kTransport.type)
}
#endif
inline void Warhamer40kTransport::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Warhamer40kTransport.type)
}
inline void Warhamer40kTransport::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Warhamer40kTransport.type)
}
inline ::std::string* Warhamer40kTransport::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:Warhamer40kTransport.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Warhamer40kTransport::release_type() {
  // @@protoc_insertion_point(field_release:Warhamer40kTransport.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Warhamer40kTransport::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:Warhamer40kTransport.type)
}

// uint32 transport = 5;
inline void Warhamer40kTransport::clear_transport() {
  transport_ = 0u;
}
inline ::google::protobuf::uint32 Warhamer40kTransport::transport() const {
  // @@protoc_insertion_point(field_get:Warhamer40kTransport.transport)
  return transport_;
}
inline void Warhamer40kTransport::set_transport(::google::protobuf::uint32 value) {
  
  transport_ = value;
  // @@protoc_insertion_point(field_set:Warhamer40kTransport.transport)
}

// uint32 access_pts = 6;
inline void Warhamer40kTransport::clear_access_pts() {
  access_pts_ = 0u;
}
inline ::google::protobuf::uint32 Warhamer40kTransport::access_pts() const {
  // @@protoc_insertion_point(field_get:Warhamer40kTransport.access_pts)
  return access_pts_;
}
inline void Warhamer40kTransport::set_access_pts(::google::protobuf::uint32 value) {
  
  access_pts_ = value;
  // @@protoc_insertion_point(field_set:Warhamer40kTransport.access_pts)
}

// uint32 fire_pts = 7;
inline void Warhamer40kTransport::clear_fire_pts() {
  fire_pts_ = 0u;
}
inline ::google::protobuf::uint32 Warhamer40kTransport::fire_pts() const {
  // @@protoc_insertion_point(field_get:Warhamer40kTransport.fire_pts)
  return fire_pts_;
}
inline void Warhamer40kTransport::set_fire_pts(::google::protobuf::uint32 value) {
  
  fire_pts_ = value;
  // @@protoc_insertion_point(field_set:Warhamer40kTransport.fire_pts)
}

// repeated .Weapon weapon = 8;
inline int Warhamer40kTransport::weapon_size() const {
  return weapon_.size();
}
inline void Warhamer40kTransport::clear_weapon() {
  weapon_.Clear();
}
inline ::Weapon* Warhamer40kTransport::mutable_weapon(int index) {
  // @@protoc_insertion_point(field_mutable:Warhamer40kTransport.weapon)
  return weapon_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Weapon >*
Warhamer40kTransport::mutable_weapon() {
  // @@protoc_insertion_point(field_mutable_list:Warhamer40kTransport.weapon)
  return &weapon_;
}
inline const ::Weapon& Warhamer40kTransport::weapon(int index) const {
  // @@protoc_insertion_point(field_get:Warhamer40kTransport.weapon)
  return weapon_.Get(index);
}
inline ::Weapon* Warhamer40kTransport::add_weapon() {
  // @@protoc_insertion_point(field_add:Warhamer40kTransport.weapon)
  return weapon_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Weapon >&
Warhamer40kTransport::weapon() const {
  // @@protoc_insertion_point(field_list:Warhamer40kTransport.weapon)
  return weapon_;
}

// -------------------------------------------------------------------

// Weapon

// uint32 range = 1;
inline void Weapon::clear_range() {
  range_ = 0u;
}
inline ::google::protobuf::uint32 Weapon::range() const {
  // @@protoc_insertion_point(field_get:Weapon.range)
  return range_;
}
inline void Weapon::set_range(::google::protobuf::uint32 value) {
  
  range_ = value;
  // @@protoc_insertion_point(field_set:Weapon.range)
}

// uint32 attacks = 2;
inline void Weapon::clear_attacks() {
  attacks_ = 0u;
}
inline ::google::protobuf::uint32 Weapon::attacks() const {
  // @@protoc_insertion_point(field_get:Weapon.attacks)
  return attacks_;
}
inline void Weapon::set_attacks(::google::protobuf::uint32 value) {
  
  attacks_ = value;
  // @@protoc_insertion_point(field_set:Weapon.attacks)
}

// uint32 strengh = 3;
inline void Weapon::clear_strengh() {
  strengh_ = 0u;
}
inline ::google::protobuf::uint32 Weapon::strengh() const {
  // @@protoc_insertion_point(field_get:Weapon.strengh)
  return strengh_;
}
inline void Weapon::set_strengh(::google::protobuf::uint32 value) {
  
  strengh_ = value;
  // @@protoc_insertion_point(field_set:Weapon.strengh)
}

// uint32 armor_peircing = 4;
inline void Weapon::clear_armor_peircing() {
  armor_peircing_ = 0u;
}
inline ::google::protobuf::uint32 Weapon::armor_peircing() const {
  // @@protoc_insertion_point(field_get:Weapon.armor_peircing)
  return armor_peircing_;
}
inline void Weapon::set_armor_peircing(::google::protobuf::uint32 value) {
  
  armor_peircing_ = value;
  // @@protoc_insertion_point(field_set:Weapon.armor_peircing)
}

// string text = 5;
inline void Weapon::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Weapon::text() const {
  // @@protoc_insertion_point(field_get:Weapon.text)
  return text_.GetNoArena();
}
inline void Weapon::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Weapon.text)
}
#if LANG_CXX11
inline void Weapon::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Weapon.text)
}
#endif
inline void Weapon::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Weapon.text)
}
inline void Weapon::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Weapon.text)
}
inline ::std::string* Weapon::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:Weapon.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Weapon::release_text() {
  // @@protoc_insertion_point(field_release:Weapon.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Weapon::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:Weapon.text)
}

// .Type type = 6;
inline bool Weapon::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void Weapon::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) {
    delete type_;
  }
  type_ = NULL;
}
inline const ::Type& Weapon::_internal_type() const {
  return *type_;
}
inline const ::Type& Weapon::type() const {
  const ::Type* p = type_;
  // @@protoc_insertion_point(field_get:Weapon.type)
  return p != NULL ? *p : *reinterpret_cast<const ::Type*>(
      &::_Type_default_instance_);
}
inline ::Type* Weapon::release_type() {
  // @@protoc_insertion_point(field_release:Weapon.type)
  
  ::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::Type* Weapon::mutable_type() {
  
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::Type>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Weapon.type)
  return type_;
}
inline void Weapon::set_allocated_type(::Type* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_;
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:Weapon.type)
}

// uint32 damage = 7;
inline void Weapon::clear_damage() {
  damage_ = 0u;
}
inline ::google::protobuf::uint32 Weapon::damage() const {
  // @@protoc_insertion_point(field_get:Weapon.damage)
  return damage_;
}
inline void Weapon::set_damage(::google::protobuf::uint32 value) {
  
  damage_ = value;
  // @@protoc_insertion_point(field_set:Weapon.damage)
}

// -------------------------------------------------------------------

// Type

// string name = 1;
inline void Type::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type::name() const {
  // @@protoc_insertion_point(field_get:Type.name)
  return name_.GetNoArena();
}
inline void Type::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Type.name)
}
#if LANG_CXX11
inline void Type::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Type.name)
}
#endif
inline void Type::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Type.name)
}
inline void Type::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Type.name)
}
inline ::std::string* Type::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Type.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type::release_name() {
  // @@protoc_insertion_point(field_release:Type.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Type.name)
}

// string text = 2;
inline void Type::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type::text() const {
  // @@protoc_insertion_point(field_get:Type.text)
  return text_.GetNoArena();
}
inline void Type::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Type.text)
}
#if LANG_CXX11
inline void Type::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Type.text)
}
#endif
inline void Type::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Type.text)
}
inline void Type::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Type.text)
}
inline ::std::string* Type::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:Type.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type::release_text() {
  // @@protoc_insertion_point(field_release:Type.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:Type.text)
}

// -------------------------------------------------------------------

// Power

// string name = 1;
inline void Power::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Power::name() const {
  // @@protoc_insertion_point(field_get:Power.name)
  return name_.GetNoArena();
}
inline void Power::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Power.name)
}
#if LANG_CXX11
inline void Power::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Power.name)
}
#endif
inline void Power::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Power.name)
}
inline void Power::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Power.name)
}
inline ::std::string* Power::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Power.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Power::release_name() {
  // @@protoc_insertion_point(field_release:Power.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Power::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Power.name)
}

// string text = 2;
inline void Power::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Power::text() const {
  // @@protoc_insertion_point(field_get:Power.text)
  return text_.GetNoArena();
}
inline void Power::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Power.text)
}
#if LANG_CXX11
inline void Power::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Power.text)
}
#endif
inline void Power::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Power.text)
}
inline void Power::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Power.text)
}
inline ::std::string* Power::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:Power.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Power::release_text() {
  // @@protoc_insertion_point(field_release:Power.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Power::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:Power.text)
}

// .Weapon stats = 3;
inline bool Power::has_stats() const {
  return this != internal_default_instance() && stats_ != NULL;
}
inline void Power::clear_stats() {
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) {
    delete stats_;
  }
  stats_ = NULL;
}
inline const ::Weapon& Power::_internal_stats() const {
  return *stats_;
}
inline const ::Weapon& Power::stats() const {
  const ::Weapon* p = stats_;
  // @@protoc_insertion_point(field_get:Power.stats)
  return p != NULL ? *p : *reinterpret_cast<const ::Weapon*>(
      &::_Weapon_default_instance_);
}
inline ::Weapon* Power::release_stats() {
  // @@protoc_insertion_point(field_release:Power.stats)
  
  ::Weapon* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline ::Weapon* Power::mutable_stats() {
  
  if (stats_ == NULL) {
    auto* p = CreateMaybeMessage<::Weapon>(GetArenaNoVirtual());
    stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Power.stats)
  return stats_;
}
inline void Power::set_allocated_stats(::Weapon* stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_;
  }
  if (stats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:Power.stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_warhammer40kUnit_2eproto
